GFG Link : https://www.geeksforgeeks.org/problems/pythagorean-triplet3018/1

Brute Force:
Time complexity : O(N^3)

class Solution{
public:
	bool checkTriplet(int arr[], int n) {
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                for(int k=j+1;k<n;k++){
                    int a = arr[i]*arr[i];
                    int b = arr[j]*arr[j];
                    int c = arr[k]*arr[k];
                    if((a+b==c) || (b+c==a) || (a+c==b)){
                        return true;
                    }
                }
            }
        }
        return false;
	}
};

Better solution:
Time complexity : O(N^2)
Space complexity : O(N) for storing square values

class Solution{
public:
	bool checkTriplet(int arr[], int n) {
	    unordered_set<int> s;
	    for(int i=0;i<n;i++)
	        s.insert(arr[i]*arr[i]);
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int a = arr[i]*arr[i];
                int b = arr[j]*arr[j];
                if(s.find(a+b)!=s.end())
                    return true;
            }
        }
        return false;
	}
};

Optimal Solution: sorting and using two pointer approach
Time complexity : O(NlogN + O(N^2)) = O(N^2)

class Solution{
public:
	bool checkTriplet(int arr[], int n) {
        for(int i=0;i<n;i++)
            arr[i] = arr[i]*arr[i];
        sort(arr,arr+n);
        for(int i=n-1;i>=2;i--){
            int start = 0,end=i-1;
            while(start<end){
                if(arr[start]+arr[end]==arr[i])
                    return true;
                else if(arr[start]+arr[end]<arr[i])
                    start++;
                else
                    end--;
            }
        }
        return false;
	}
};

